/*
 * stm32f767xx_i2c_driver.c
 *
 *  Created on: Aug 28, 2025
 *      Author: TUF
 */

#include "stm32f767xx.h"
#include "stm32f767xx_i2c_driver.h"

uint32_t RCCGetPLLOutputClock(void){
	return 0;
}

uint32_t RCC_GetPCLK1Value(void){
	uint32_t pclk1, SystemCLk;
	uint8_t clksrc, temp;

	clksrc = ((RCC->CFGR >> 2) & 0x3);

	if(clksrc == 0){
		//HSI
		SystemCLk = 16000000;
	}
	else if(clksrc == 1){
		//HSE
		SystemCLk = 8000000;
	}
	else if(clksrc == 2){
		//PLL
		SystemCLk = RCCGetPLLOutputClock();
	}
}


void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t EnorDi){
	//CR1_PE
	if(EnorDi == ENABLE)
	{
		pI2Cx->CR1 |= (1 << I2C_CR1_PE); //enable
	}
	else
	{
		pI2Cx->CR1 &= ~(1 << I2C_CR1_PE); //disable
	}
}

void I2C_PeriClockControl(I2C_RegDef_t *pI2Cx, uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_EN();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_EN();
		}
		else if(pI2Cx == I2C4)
		{
			I2C4_PCLK_EN();
		}


	}
	else
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_DI();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_DI();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_DI();
		}
		else if(pI2Cx == I2C4)
		{
			I2C4_PCLK_DI();
		}

	}

}

void I2C_Init(I2C_Handle_t *pI2CHandle);
void I2C_DeInit(I2C_RegDef_t *pI2Cx); //take base address of peripheral (reset register)
